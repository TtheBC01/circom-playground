import {
  Circuit,
  circuitMain,
  public_,
  Poseidon,
  Field,
  MerkleTree,
  MerkleWitness,
  Struct,
  Encoding,
} from 'snarkyjs';

// we need to declare the size of our witness before we can make a circuit with it
// lets choose arity = 16 for 2^16 possible entries 
class MyMerkleWitness extends MerkleWitness(16) {}

// create a useful data structure for identity commitments 
class Identity extends Struct({
  identityTrapdoor: Field,
  identityNullifier: Field,
}) {
  // we have to hash this stuff twice for the semaphore protocol
  secret(): Field {
    return Poseidon.hash([this.identityTrapdoor, this.identityNullifier]);
  }

  leaf(): Field {
    return Poseidon.hash([this.secret()]);
  }
}

class Merkle_Tree_Circuit extends Circuit {
  @circuitMain
  static main(@public_ merkleRoot: Field, 
              @public_ epochNullifier: Field, 
              @public_ signalNullifier: Field, 
              @public_ signalHash: Field,
              @public_ signalHashSquared: Field,
              identity: Identity, 
              path: MyMerkleWitness) {

    // we check that the identity is contained in the committed Merkle Tree
    path.calculateRoot(identity.leaf()).assertEquals(merkleRoot);

    // now we check that the signalNullifier was computed properly to prevent double tapping (order matters)
    Poseidon.hash([identity.identityNullifier, epochNullifier]).assertEquals(signalNullifier);

    // check that the communicated signal has not been tampered with
    signalHash.mul(signalHash).assertEquals(signalHashSquared);
  }
}

console.log('generating keypair...');
console.time('generating keypair...');
const kp = await Merkle_Tree_Circuit.generateKeypair();
console.timeEnd('generating keypair...');
let vk = kp.verificationKey();

// pretend like we're fetching info from the blockchain to construct our anonymity group
type Names = 'Bob' | 'Alice' | 'Charlie' | 'Olivia';
let Identities: Map<string, Identity> = new Map<Names, Identity>(
  ['Bob', 'Alice', 'Charlie', 'Olivia'].map((name: string, index: number) => {
    return [
      name as Names,
      new Identity({
        identityTrapdoor: Field.random(),
        identityNullifier: Field.random(),
      }),
    ];
  })
);

// construct a fake signal, just make it an arbitrary string
let signal: string = "Here is my signal string." 

// then convert the string to an array of Field elements appropriate for Poseidon hashing
let signalFields = Encoding.stringToFields(signal);

// verifier should compute these quantities for themselves upon receiving the signal 
let signalHash: Field = Poseidon.hash([...signalFields]);
let signalHashSquared: Field = signalHash.mul(signalHash);

// Compress the anonymity group into a Merkle Tree object
const Identity_Tree = new MerkleTree(16);
Identity_Tree.setLeaf(0n, Identities.get('Bob')!.leaf());
Identity_Tree.setLeaf(1n, Identities.get('Alice')!.leaf());
Identity_Tree.setLeaf(2n, Identities.get('Charlie')!.leaf());
Identity_Tree.setLeaf(3n, Identities.get('Olivia')!.leaf());

// calculate the merkleRoot from the tree object
let merkleRoot: Field = Identity_Tree.getRoot(); // Calculate your merkleRoot reference (this can be computed independently by anyone)

// construct the private witness object for Bob
let userIndex = 0n; 
let userIdentity = Identities.get('Bob')!;
let w = Identity_Tree.getWitness(userIndex); // calculate the witness for the first slot with your private data
let witness = new MyMerkleWitness(w);

// compute the signal nullifier from user's secret identityNullifier
// FYI: the order of the array in the Poseidon hash matters
let epochNullifier: Field = Field.random();
let signalNullifier: Field = Poseidon.hash([userIdentity.identityNullifier, epochNullifier]);

console.log('prove...');
console.time('prove...');
// inputs are: [private input array], [public input array], keypair from .generateKeypair()
const proof = await Merkle_Tree_Circuit.prove([userIdentity, witness], [merkleRoot, epochNullifier, signalNullifier, signalHash, signalHashSquared], kp); 
console.timeEnd('prove...');

console.log('verify...');
console.time('verify...');
// inputs are: [public input array], verification key, proof generated by calling .prove()
let ok = await Merkle_Tree_Circuit.verify([merkleRoot, epochNullifier, signalNullifier, signalHash, signalHashSquared], vk, proof);
console.timeEnd('verify...');

console.log('ok?', ok);
