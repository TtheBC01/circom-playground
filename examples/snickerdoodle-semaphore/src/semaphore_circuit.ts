import {
  Poseidon,
  Field,
  MerkleTree,
  Encoding,
} from 'snarkyjs';

import { Identity, MyMerkleWitness, Semaphore_Circuit  } from './Semaphore.js';

console.log('generating keypair...');
console.time('generating keypair...');
const kp = await Semaphore_Circuit.generateKeypair();
console.timeEnd('generating keypair...');
let vk = kp.verificationKey();

// pretend like we're fetching info from the blockchain to construct our anonymity group
type Names = 'Bob' | 'Alice' | 'Charlie' | 'Olivia';
let Identities: Map<string, Identity> = new Map<Names, Identity>(
  ['Bob', 'Alice', 'Charlie', 'Olivia'].map((name: string, index: number) => {
    return [
      name as Names,
      new Identity({
        identityTrapdoor: Field.random(),
        identityNullifier: Field.random(),
      }),
    ];
  })
);

// construct a fake signal, just make it an arbitrary string
let signal: string = "Here is my signal string." 

// then convert the string to an array of Field elements appropriate for Poseidon hashing
let signalFields = Encoding.stringToFields(signal);

// verifier should compute these quantities for themselves upon receiving the signal 
let signalHash: Field = Poseidon.hash([...signalFields]);
let signalHashSquared: Field = signalHash.mul(signalHash);

// Compress the anonymity group into a Merkle Tree object
const Identity_Tree = new MerkleTree(16);
Identity_Tree.setLeaf(0n, Identities.get('Bob')!.leaf());
Identity_Tree.setLeaf(1n, Identities.get('Alice')!.leaf());
Identity_Tree.setLeaf(2n, Identities.get('Charlie')!.leaf());
Identity_Tree.setLeaf(3n, Identities.get('Olivia')!.leaf());

// calculate the merkleRoot from the tree object
let merkleRoot: Field = Identity_Tree.getRoot(); // Calculate your merkleRoot reference (this can be computed independently by anyone)

// construct the private witness object for Bob
let userIndex = 0n; 
let userIdentity = Identities.get('Bob')!;
let w = Identity_Tree.getWitness(userIndex); // calculate the witness for the first slot with your private data
let witness = new MyMerkleWitness(w);

// compute the signal nullifier from user's secret identityNullifier
// FYI: the order of the array in the Poseidon hash matters
let epochNullifier: Field = Field.random();
let signalNullifier: Field = Poseidon.hash([userIdentity.identityNullifier, epochNullifier]);

console.log('prove...');
console.time('prove...');
// inputs are: [private input array], [public input array], keypair from .generateKeypair()
const proof = await Semaphore_Circuit.prove([userIdentity, witness], [merkleRoot, epochNullifier, signalNullifier, signalHash, signalHashSquared], kp); 
console.timeEnd('prove...');

console.log('verify...');
console.time('verify...');
// inputs are: [public input array], verification key, proof generated by calling .prove()
let ok = await Semaphore_Circuit.verify([merkleRoot, epochNullifier, signalNullifier, signalHash, signalHashSquared], vk, proof);
console.timeEnd('verify...');

console.log('ok?', ok);
